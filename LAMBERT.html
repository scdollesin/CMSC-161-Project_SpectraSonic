<!DOCTYPE html>
<html>
<head>
  <script type="x-shader/x-vertex" id="vshader">
      attribute vec4 aPosition;
      attribute vec4 aNormal;   //variable for normal vector at each vertex

      uniform mat4 uModelMatrix;                //Model Matrix
      uniform mat4 uViewMatrix;                 //View Matrix
      uniform mat4 uProjectionMatrix;           //Projection Matrix

      uniform mat4 uNormalMatrix;               //Normal Matrix
      
      uniform vec4 uMaterialDiffuseColor;       //Kd
      uniform vec4 uLightDiffuseColor;          //Ld

      uniform vec4 uLightDirectionVector;       //l

      varying vec4 vDiffuseColor;

    void main() {
      gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;

      //get Corrected Normal vector from transformation
      vec4 corrected_aNormal = uNormalMatrix * aNormal;
      
      //get normalized normal and light vector
      vec4 normalized_aNormalVector = normalize(corrected_aNormal);
      vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);


      //get lambertCooeficient = (-l . n)
      float lambertCoefficient = max(dot(-normalized_uLightDirectionVector, normalized_aNormalVector), 0.0);

      //Fd = Ld * Kd * (n dot -l)
      vec4 diffuseColor = uMaterialDiffuseColor * uLightDiffuseColor * lambertCoefficient;

      vDiffuseColor = vec4(diffuseColor.rgb, 1.0);
    }
  </script>

  <script type="x-shader/x-fragment" id="fshader">
    precision mediump float;

    varying vec4 vDiffuseColor;

    void main() {
      gl_FragColor = vDiffuseColor;
    }
  </script>

  <!--Import external javascript file-->
  <script src="./lib/webgl-init.js"></script>
  <script src="./lib/webgl-utils.js"></script>
  <script src="./lib/webgl-debug.js"></script>
  <script src="./lib/gl-matrix-min.js"></script>

  <script>
    var rotationAngle = 0;
    var rotationSpeed = 0.01;
    var rotationDirection = -1; // Clockwise rotation
    var rotateActive = false;   // Variable to indicate whether rotation is active

    // Default values for light direction, light color, and eye position
    var lightDirection = [-1.0, -3.0, -5.0, 0.0];
    var lightColor = [1.0, 1.0, 1.0, 1.0];
    var eyePosition = [3.0, 4.0, 5.0];

    function toggleRotation() {
      rotateActive = !rotateActive;
      if (rotateActive) {
        requestAnimationFrame(animateRotation);
      }
    }

    function animateRotation() {
      if (rotateActive) {
        rotationAngle += rotationSpeed * rotationDirection;
        drawScene();
        requestAnimationFrame(animateRotation);
      }
    }

    function drawScene() {
      // Retrieve <canvas> element
      var canvas = document.getElementById("main_canvas");
      if (!canvas) {
        console.log("Failed to retrieve the <canvas> element");
        return;
      }

      // Get the rendering context (WebGL)
      var gl = initializeWebGL(canvas, true);

      // Initialize shaders program
      var vertexShader = initializeShader(gl, "vshader");
      var fragmentShader = initializeShader(gl, "fshader");
      var program = initializeProgram(gl, vertexShader, fragmentShader);
      gl.useProgram(program);

      var aPositionPointer = gl.getAttribLocation(program, "aPosition");
      gl.enableVertexAttribArray(aPositionPointer);
      var aNormalPointer = gl.getAttribLocation(program, "aNormal");
      gl.enableVertexAttribArray(aNormalPointer);

      var uFragColorPointer = gl.getUniformLocation(program,"uColor");
      
      var uModelMatrixPointer = gl.getUniformLocation(program, "uModelMatrix");
      var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
      var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");
      var uNormalMatrixPtr = gl.getUniformLocation(program, "uNormalMatrix");

      gl.clearColor(.4, .3, .5, 1.0); // BLUE - RGBA
      gl.clear(gl.COLOR_BUFFER_BIT);

      // Enable depth testing
      gl.enable(gl.DEPTH_TEST);
      gl.clear(gl.DEPTH_BUFFER_BIT);
      

        /**START PROJECTION MATRIX SPECIFICATION**/
      var fieldOfViewYAxis = glMatrix.toRadian(30);
      var aspectRatio = canvas.width / canvas.height;
      var nearPlane = 1;
      var farPlane = 100;

      var projectionMatrix = mat4.create();

      mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
      gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));

        /**START VIEW MATRIX SPECIFICATION**/
        var lookAtPoint = [0.0,0.0,0.0,1.0];              //where the camera is looking
        var eyePoint    = [3.0,4.0,5.0,1.0];              //where the camera is placed
        var upVector    = [0.0,1.0,0.0,0.0];              //orientation of the camera

      var viewMatrix = mat4.create();  
      mat4.lookAt(viewMatrix, eyePosition, lookAtPoint, upVector);
      gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));

      // Model matrix
      var modelMatrix = mat4.create();
      mat4.identity(modelMatrix);
      mat4.rotateY(modelMatrix, modelMatrix, rotationAngle);
      gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));

      // Normal matrix
      var normalMatrix = mat4.create();
      //var uNormalMatrixPtr = gl.getUniformLocation(program,"uNormalMatrix");
      mat4.invert(normalMatrix, modelMatrix);
      mat4.transpose(normalMatrix, normalMatrix);
      gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(normalMatrix));

      // Set up light and material parameters
      var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
      gl.uniform4f(uMaterialDiffuseColorPtr, 1.0, 1.0, 1.0, 1.0);

      var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightDiffuseColor");
      gl.uniform4fv(uLightDiffuseColorPtr, lightColor);

      var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");
      gl.uniform4fv(uLightDirectionVectorPtr, lightDirection);

      // Coordinates of the cube
      var vertices = [
        // Front face
        -1.0, -1.0, 1.0, 1.0,
        1.0, -1.0, 1.0, 1.0,
        1.0, 1.0, 1.0, 1.0,
        -1.0, 1.0, 1.0, 1.0,
        // Back face
        -1.0, -1.0, -1.0, 1.0,
        -1.0, 1.0, -1.0, 1.0,
        1.0, 1.0, -1.0, 1.0,
        1.0, -1.0, -1.0, 1.0,
        // Top face
        -1.0, 1.0, -1.0, 1.0,
        -1.0, 1.0, 1.0, 1.0,
        1.0, 1.0, 1.0, 1.0,
        1.0, 1.0, -1.0, 1.0,
        // Bottom face
        -1.0, -1.0, -1.0, 1.0,
        1.0, -1.0, -1.0, 1.0,
        1.0, -1.0, 1.0, 1.0,
        -1.0, -1.0, 1.0, 1.0,
        // Right face
        1.0, -1.0, -1.0, 1.0,
        1.0, 1.0, -1.0, 1.0,
        1.0, 1.0, 1.0, 1.0,
        1.0, -1.0, 1.0, 1.0,
        // Left face
        -1.0, -1.0, -1.0, 1.0,
        -1.0, -1.0, 1.0, 1.0,
        -1.0, 1.0, 1.0, 1.0,
        -1.0, 1.0, -1.0, 1.0
      ];

      var indices = [
        0, 1, 2, 0, 2, 3, // Front face
        4, 5, 6, 4, 6, 7, // Back face
        8, 9, 10, 8, 10, 11, // Top face
        12, 13, 14, 12, 14, 15, // Bottom face
        16, 17, 18, 16, 18, 19, // Right face
        20, 21, 22, 20, 22, 23 // Left face
      ];

      var normals = [
        // Normal of each vertex
        0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, // Front face
        0.0,0.0,1.0,0.0,
        0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, // Back face
        0.0, 0.0, -1.0, 0.0,
        0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, // Top face
        0.0, 1.0, 0.0, 0.0,
        0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, // Bottom face
        0.0, -1.0, 0.0, 0.0,
        1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, // Right face
        1.0, 0.0, 0.0, 0.0,
        -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0 ,// Left face
        -1.0,0.0,0.0,0.0
      ];

      // Buffer creation
      var verticesBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aPositionPointer);

      // Indices buffer creation
      var indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);

      // Normals buffer creation
      var normalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
      gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aNormalPointer);

      // Draw part
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
    }

    function main() {
      drawScene();
      document.getElementById("rotateButton").addEventListener("click", toggleRotation);

      // Sliders for light direction
      var lightDirectionSliders = document.getElementsByClassName("lightDirectionSlider");
      for (var i = 0; i < lightDirectionSliders.length; i++) {
        lightDirectionSliders[i].addEventListener("input", function() {
          var axis = parseInt(this.dataset.axis);
          lightDirection[axis] = parseFloat(this.value);
          drawScene();
        });
      }

      // Sliders for light color
      var lightColorSliders = document.getElementsByClassName("lightColorSlider");
      for (var i = 0; i < lightColorSliders.length; i++) {
        lightColorSliders[i].addEventListener("input", function() {
          var component = parseInt(this.dataset.component);
          lightColor[component] = parseFloat(this.value);
          drawScene();
        });
      }

      // Sliders for eye position
      var eyePositionSliders = document.getElementsByClassName("eyePositionSlider");
      for (var i = 0; i < eyePositionSliders.length; i++) {
        eyePositionSliders[i].addEventListener("input", function() {
          var axis = parseInt(this.dataset.axis);
          eyePosition[axis] = parseFloat(this.value);
          drawScene();
        });
      }
    }
  </script>
</head>
<body onload="main()">
  <canvas id="main_canvas" width="600" height="600" style="border: 1px black solid;"></canvas>
  <button id="rotateButton">Toggle Rotation</button>
  <div>
    <h3>Light Direction</h3>
    <label>X: <input type="range" class="lightDirectionSlider" data-axis="0" min="-10" max="10" step="0.1" value="-1"></label>
    <label>Y: <input type="range" class="lightDirectionSlider" data-axis="1" min="-10" max="10" step="0.1" value="-3"></label>
    <label>Z: <input type="range" class="lightDirectionSlider" data-axis="2" min="-10" max="10" step="0.1" value="-5"></label>
  </div>
  <div>
    <h3>Light Color</h3>
    <label>R: <input type="range" class="lightColorSlider" data-component="0" min="0" max="1" step="0.01" value="1"></label>
    <label>G: <input type="range" class="lightColorSlider" data-component="1" min="0" max="1" step="0.01" value="1"></label>
    <label>B: <input type="range" class="lightColorSlider" data-component="2" min="0" max="1" step="0.01" value="1"></label>
  </div>
  <div>
    <h3>Eye Position</h3>
    <label>X: <input type="range" class="eyePositionSlider" data-axis="0" min="-10" max="10" step="0.1" value="3"></label>
    <label>Y: <input type="range" class="eyePositionSlider" data-axis="1" min="-10" max="10" step="0.1" value="4"></label>
    <label>Z: <input type="range" class="eyePositionSlider" data-axis="2" min="-10" max="10" step="0.1" value="5"></label>
  </div>
</body>
</html>
