<!DOCTYPE html>
<html>
<head>
  <script type="x-shader/x-vertex" id="vshader">
      attribute vec4 aPosition;
      attribute vec4 aNormal;

      uniform mat4 uModelMatrix;
      uniform mat4 uViewMatrix;
      uniform mat4 uProjectionMatrix;
      uniform mat4 uNormalMatrix;

      uniform vec4 uMaterialDiffuseColor;
      uniform vec4 uLightDiffuseColor;
      uniform vec4 uLightDirectionVector;

      varying vec4 vDiffuseColor;

      void main() {
        gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * aPosition;

        vec4 corrected_aNormal = uNormalMatrix * aNormal;
        
        vec4 normalized_aNormalVector = normalize(corrected_aNormal);
        vec4 normalized_uLightDirectionVector = normalize(uLightDirectionVector);

        float lambertCoefficient = max(dot(-normalized_uLightDirectionVector, normalized_aNormalVector), 0.0);

        vec4 diffuseColor = uMaterialDiffuseColor * uLightDiffuseColor * lambertCoefficient;

        vDiffuseColor = vec4(diffuseColor.rgb, 1.0);
      }
  </script>

  <script type="x-shader/x-fragment" id="fshader">
    precision mediump float;

    varying vec4 vDiffuseColor;

    void main() {
      gl_FragColor = vDiffuseColor;
    }
  </script>

  <script src="./lib/webgl-init.js"></script>
  <script src="./lib/webgl-utils.js"></script>
  <script src="./lib/webgl-debug.js"></script>
  <script src="./lib/gl-matrix-min.js"></script>

  <script>
    var rotationAngleX = 0;
    var rotationAngleY = 0;
    var previousMouseX;
    var previousMouseY;
    var isDragging = false;


    var key1Vertices =[
    -0.906, 0.285, 0.0, 1.0, 
  -0.906, -0.132, 0.0, 1.0, 
  -0.899, -0.149, 0.0, 1.0, 
  -0.884, -0.16, 0.0, 1.0, 
  -0.848, -0.163, 0.0, 1.0, 
  -0.848, -0.478, 0.0, 1.0, 
  -0.943, -0.478, 0.0, 1.0, 
  -0.964, -0.475, 0.0, 1.0, 
  -0.978, -0.458, 0.0, 1.0, 
  -0.982, -0.436, 0.0, 1.0, 
  -0.982, 0.285, 0.0, 1.0, 
  -0.906, 0.285, 0.03, 1.0, 
  -0.906, -0.132, 0.03, 1.0, 
  -0.899, -0.149, 0.03, 1.0, 
  -0.884, -0.16, 0.03, 1.0, 
  -0.848, -0.163, 0.03, 1.0, 
  -0.848, -0.478, 0.03, 1.0, 
  -0.943, -0.478, 0.03, 1.0, 
  -0.964, -0.475, 0.03, 1.0, 
  -0.978, -0.458, 0.03, 1.0, 
  -0.982, -0.436, 0.03, 1.0, 
  -0.982, 0.285, 0.03, 1.0

    ];
 var key1Indices= [
      10.0, 2.0, 3.0, 
      14.0, 15.0, 21.0, 
      1.0, 13.0, 2.0, 
      1.0, 22.0, 12.0, 
      11.0, 21.0, 22.0, 
      10.0, 20.0, 21.0, 
      9.0, 19.0, 20.0, 
      8.0, 18.0, 19.0, 
      7.0, 17.0, 18.0, 
      6.0, 16.0, 17.0, 
      5.0, 15.0, 16.0, 
      4.0, 14.0, 15.0, 
      3.0, 13.0, 14.0, 
      4.0, 5.0, 10.0, 
      5.0, 6.0, 10.0, 
      6.0, 7.0, 10.0, 
      7.0, 8.0, 9.0, 
      10.0, 7.0, 9.0, 
      10.0, 11.0, 2.0, 
      11.0, 1.0, 2.0, 
      3.0, 4.0, 10.0, 
      20.0, 21.0, 18.0, 
      21.0, 22.0, 13.0, 
      22.0, 12.0, 13.0, 
      21.0, 13.0, 14.0, 
      18.0, 21.0, 17.0, 
      18.0, 19.0, 20.0, 
      16.0, 17.0, 21.0, 
      15.0, 16.0, 21.0, 
      1.0, 12.0, 13.0, 
      1.0, 11.0, 22.0, 
      11.0, 10.0, 21.0, 
      10.0, 9.0, 20.0, 
      9.0, 8.0, 19.0, 
      8.0, 7.0, 18.0, 
      7.0, 6.0, 17.0, 
      6.0, 5.0, 16.0, 
      5.0, 4.0, 15.0, 
      4.0, 3.0, 14.0, 
      3.0, 2.0, 13.0,

 ];
   var key1Normals = [
        -0.0, -0.0, -1.0, 0, 
        1.0, -0.0, -0.0, 0, 
        -0.0, 1.0, -0.0, 0, 
        -1.0, -0.0, -0.0, 0, 
        -0.9839, -0.1789, -0.0, 0, 
        -0.7719, -0.6357, -0.0, 0, 
        -0.1414, -0.9899, -0.0, 0, 
        -0.0, -1.0, -0.0, 0, 
        0.083, 0.9965, -0.0, 0, 
        0.5914, 0.8064, -0.0, 0, 
        0.9247, 0.3808, -0.0, 0,
   ];


    var vertices2 = [
      // Cube vertices
      // Front face
      2.0, -1.0, 1.0, 1.0,
      4.0, -1.0, 1.0, 1.0,
      4.0, 1.0, 1.0, 1.0,
      2.0, 1.0, 1.0, 1.0,
      // Back face
      2.0, -1.0, -1.0, 1.0,
      2.0, 1.0, -1.0, 1.0,
      4.0, 1.0, -1.0, 1.0,
      4.0, -1.0, -1.0, 1.0,
      // Top face
      2.0, 1.0, -1.0, 1.0,
      2.0, 1.0, 1.0, 1.0,
      4.0, 1.0, 1.0, 1.0,
      4.0, 1.0, -1.0, 1.0,
      // Bottom face
      2.0, -1.0, -1.0, 1.0,
      4.0, -1.0, -1.0, 1.0,
      4.0, -1.0, 1.0, 1.0,
      2.0, -1.0, 1.0, 1.0,
      // Right face
      4.0, -1.0, -1.0, 1.0,
      4.0, 1.0, -1.0, 1.0,
      4.0, 1.0, 1.0, 1.0,
      4.0, -1.0, 1.0, 1.0,
      // Left face
      2.0, -1.0, -1.0, 1.0,
      2.0, -1.0, 1.0, 1.0,
      2.0, 1.0, 1.0, 1.0,
      2.0, 1.0, -1.0, 1.0
    ];



    var vertices = [
      // Cube vertices
      // Front face
      -1.0, -1.0, 1.0, 1.0,
      1.0, -1.0, 1.0, 1.0,
      1.0, 1.0, 1.0, 1.0,
      -1.0, 1.0, 1.0, 1.0,
      // Back face
      -1.0, -1.0, -1.0, 1.0,
      -1.0, 1.0, -1.0, 1.0,
      1.0, 1.0, -1.0, 1.0,
      1.0, -1.0, -1.0, 1.0,
      // Top face
      -1.0, 1.0, -1.0, 1.0,
      -1.0, 1.0, 1.0, 1.0,
      1.0, 1.0, 1.0, 1.0,
      1.0, 1.0, -1.0, 1.0,
      // Bottom face
      -1.0, -1.0, -1.0, 1.0,
      1.0, -1.0, -1.0, 1.0,
      1.0, -1.0, 1.0, 1.0,
      -1.0, -1.0, 1.0, 1.0,
      // Right face
      1.0, -1.0, -1.0, 1.0,
      1.0, 1.0, -1.0, 1.0,
      1.0, 1.0, 1.0, 1.0,
      1.0, -1.0, 1.0, 1.0,
      // Left face
      -1.0, -1.0, -1.0, 1.0,
      -1.0, -1.0, 1.0, 1.0,
      -1.0, 1.0, 1.0, 1.0,
      -1.0, 1.0, -1.0, 1.0
    ];

    var indices = [
      // Cube indices
      // Front face
      0, 1, 2, 0, 2, 3,
      // Back face
      4, 5, 6, 4, 6, 7,
      // Top face
      8, 9, 10, 8, 10, 11,
      // Bottom face
      12, 13, 14, 12, 14, 15,
      // Right face
      16, 17, 18, 16, 18, 19,
      // Left face
      20, 21, 22, 20, 22, 23
    ];

    var normals = [
      // Cube normals
      // Front face
      0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0,
      // Back face
      0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0,
      // Top face
      0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
      // Bottom face
      0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0,
      // Right face
      1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,
      // Left face
      -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0
    ];

    var collapseInterval;
    var collapsing = false;

    function startCollapse() {
      collapsing = true;
      //collapseInterval = setInterval(collapseTopFront, 50); // Adjust the interval as needed for the desired speed of collapse
      collapseTopFront();
    }

    function endCollapse() {
      //collapsing = false;
      //clearInterval(collapseInterval);
      goBackcollapseTopFront();

      //drawScene(); // Redraw the scene to reset the cube to its original position
    }
        function startCollapse2() {
      //collapsing = true;
      //collapseInterval = setInterval(collapseTopFront, 50); // Adjust the interval as needed for the desired speed of collapse
      collapseTopFront2();
    }

    function endCollapse2() {
      //collapsing = false;
      //clearInterval(collapseInterval);
      goBackcollapseTopFront2();

      //drawScene(); // Redraw the scene to reset the cube to its original position
    }

    function collapseTopFront() {
      // Adjust cube vertices to change shape
      for (var i = 0; i < vertices.length; i += 4) {
        if (vertices[i + 2] > 0.99) { // Check if vertex is part of the top front face
          vertices[i + 1] -= 1.0; // Move top front vertices down
        }
      }

      drawScene(); // Redraw the scene with the updated vertices
    }

        function goBackcollapseTopFront() {
      // Adjust cube vertices to change shape
      for (var i = 0; i < vertices.length; i += 4) {
        if (vertices[i + 2] > 0.99) { // Check if vertex is part of the top front face
          vertices[i + 1] += 1.0; // Move top front vertices down
        }
      }

      drawScene(); // Redraw the scene with the updated vertices
    }

    function collapseTopFront2() {
      // Adjust cube vertices to change shape
      for (var i = 0; i < vertices2.length; i += 4) {
        if (vertices2[i + 2] > 0.99) { // Check if vertex is part of the top front face
          vertices2[i + 1] -= 1.0; // Move top front vertices down
        }
      }

      drawScene(); // Redraw the scene with the updated vertices
    }

        function goBackcollapseTopFront2() {
      // Adjust cube vertices to change shape
      for (var i = 0; i < vertices2.length; i += 4) {
        if (vertices2[i + 2] > 0.99) { // Check if vertex is part of the top front face
          vertices2[i + 1] += 1.0; // Move top front vertices down
        }
      }

      drawScene(); // Redraw the scene with the updated vertices
    }


      function handleMouseMove(event) {
      if (isDragging) {
        var canvas = event.target;
        var rect = canvas.getBoundingClientRect();
        var deltaX = event.clientX - previousMouseX;
        var deltaY = event.clientY - previousMouseY;
        rotationAngleY += deltaX * 0.01;
        rotationAngleX += deltaY * 0.01;
        previousMouseX = event.clientX;
        previousMouseY = event.clientY;
        drawScene();
      }
    }

    function handleMouseDown(event) {
      var canvas = event.target;
      var rect = canvas.getBoundingClientRect();
      if (event.clientX >= rect.left && event.clientX <= rect.right &&
          event.clientY >= rect.top && event.clientY <= rect.bottom) {
        isDragging = true;
        previousMouseX = event.clientX;
        previousMouseY = event.clientY;
      }
    }

    function handleMouseUp(event) {
      isDragging = false;
    }
    // function handleMouseMove(event) {
    //   if (!isDragging) {
    //     return;
    //   }
    //   var deltaX = event.clientX - previousMouseX;
    //   var deltaY = event.clientY - previousMouseY;
    //   rotationAngleY += deltaX * 0.01;
    //   rotationAngleX += deltaY * 0.01;
    //   previousMouseX = event.clientX;
    //   previousMouseY = event.clientY;
    //   drawScene();
    // }

    // function handleMouseDown(event) {
    //   isDragging = true;
    //   previousMouseX = event.clientX;
    //   previousMouseY = event.clientY;
    // }

    // function handleMouseUp(event) {
    //   isDragging = false;
    // }

    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mousedown', handleMouseDown);
    document.addEventListener('mouseup', handleMouseUp);

    function drawScene() {
      // Retrieve <canvas> element
      var canvas = document.getElementById("main_canvas");
      if (!canvas) {
        console.log("Failed to retrieve the <canvas> element");
        return;
      }

      // Get the rendering context (WebGL)
      var gl = initializeWebGL(canvas, true);

      // Initialize shaders program, set up buffers, uniforms, etc.
      var vertexShader = initializeShader(gl, "vshader");
      var fragmentShader = initializeShader(gl, "fshader");
      var program = initializeProgram(gl, vertexShader, fragmentShader);
      gl.useProgram(program);

      var aPositionPointer = gl.getAttribLocation(program, "aPosition");
      gl.enableVertexAttribArray(aPositionPointer);
      var aNormalPointer = gl.getAttribLocation(program, "aNormal");
      gl.enableVertexAttribArray(aNormalPointer);

      var uModelMatrixPointer = gl.getUniformLocation(program, "uModelMatrix");
      var uViewMatrixPointer = gl.getUniformLocation(program, "uViewMatrix");
      var uProjectionMatrixPointer = gl.getUniformLocation(program, "uProjectionMatrix");
      var uNormalMatrixPtr = gl.getUniformLocation(program, "uNormalMatrix");

      var uMaterialDiffuseColorPtr = gl.getUniformLocation(program, "uMaterialDiffuseColor");
      gl.uniform4f(uMaterialDiffuseColorPtr, 1.0, 1.0, 1.0, 1.0);

      var uLightDiffuseColorPtr = gl.getUniformLocation(program, "uLightDiffuseColor");
      gl.uniform4fv(uLightDiffuseColorPtr, [1.0, 0.0, 1.0, 1.0]);

      var uLightDirectionVectorPtr = gl.getUniformLocation(program, "uLightDirectionVector");
      gl.uniform4fv(uLightDirectionVectorPtr, [-1.0, -3.0, -5.0, 0.0]);

      // Clear canvas and depth buffer
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

      // Set up projection, view, and model matrices
      var fieldOfViewYAxis = glMatrix.toRadian(30);
      var aspectRatio = canvas.width / canvas.height;
      var nearPlane = 1;
      var farPlane = 100;

      var projectionMatrix = mat4.create();
      mat4.perspective(projectionMatrix, fieldOfViewYAxis, aspectRatio, nearPlane, farPlane);
      gl.uniformMatrix4fv(uProjectionMatrixPointer, false, new Float32Array(projectionMatrix));

      var lookAtPoint = [1.5, 0.0, 0.0, 1.0];
      var eyePoint = [3.0, 4.0, 5.0, 1.0];
      var upVector = [0.0, 1.0, 0.0, 0.0];

      var viewMatrix = mat4.create();
      mat4.lookAt(viewMatrix, eyePoint, lookAtPoint, upVector);
      gl.uniformMatrix4fv(uViewMatrixPointer, false, new Float32Array(viewMatrix));

      var modelMatrix = mat4.create();
      mat4.identity(modelMatrix);
      mat4.rotateX(modelMatrix, modelMatrix, rotationAngleX);
      mat4.rotateY(modelMatrix, modelMatrix, rotationAngleY);
      gl.uniformMatrix4fv(uModelMatrixPointer, false, new Float32Array(modelMatrix));

      var normalMatrix = mat4.create();
      mat4.invert(normalMatrix, modelMatrix);
      mat4.transpose(normalMatrix, normalMatrix);
      gl.uniformMatrix4fv(uNormalMatrixPtr, false, new Float32Array(normalMatrix));

      var verticesBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, verticesBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aPositionPointer);



      var indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);

      var normalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
      gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aNormalPointer);

      // Draw the cube
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);
    
            var vertices2Buffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertices2Buffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices2), gl.STATIC_DRAW);
      gl.vertexAttribPointer(aPositionPointer, 4, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aPositionPointer);



      var indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint8Array(indices), gl.STATIC_DRAW);

      // var normalBuffer = gl.createBuffer();
      // gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
      // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
      // gl.vertexAttribPointer(aNormalPointer, 4, gl.FLOAT, false, 0, 0);
      // gl.enableVertexAttribArray(aNormalPointer);

      // Draw the cube
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_BYTE, 0);

    }

    function main() {
      drawScene();
    }
  </script>
</head>
<body onload="main()">
  <canvas id="main_canvas" width="1200" height="600" style="border: 1px black solid;"></canvas>
  <!-- Button to trigger collapse -->
  <button onmousedown="startCollapse()" onmouseup="endCollapse()">Collapse Top Front1</button>
  <button onmousedown="startCollapse2()" onmouseup="endCollapse2()">Collapse Top Front2</button>
</body>
</html>
